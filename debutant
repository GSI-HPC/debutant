#!/bin/sh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

###################
#
# helper function definitions for recipes:
#

abort() {
    echo $* >&2
    exit 1
}


# Add a dependency to debian/control
#  -b : Add a build-dependency
add_dependency() {
    local depends="Depends"

    if [ "$1" = "-b" ]; then
        depends="Build-Depends"
        shift
    fi

    for PKG in $@; do
        grep -q "^${depends}: .*\<$PKG\>" $DIR/DEBIAN/control \
            || sed -i -e "s/^\(${depends}: .*\)/\1, $PKG/" $DIR/DEBIAN/control
    done
}


# add a build dependency to debian/control
build_depends() {
    for PKG in $@; do
        add_dependency -b $PKG
        # TODO: install it if required ?!
    done
}


cleanup() {
    [ -d $BUILD_DIR ] && rm -r $BUILD_DIR
}


# change an option in debian/control
debian_control()  {
    local key=$1
    local value=$2
    sed -i -e "s|^\($key:\) .*|\1 $value|" debian/control    
}


debian_rules() {
    [ -e debian/rules ] && cp debian/rules debian/rules.orig
    cat > debian/rules <<EOF
#!/usr/bin/make -f
%:
EOF
# emacs tends to turn tabs into spaces, we'll clarify this:
    /bin/echo -e "\tdh \$@" >> debian/rules

    # stripping the provided binaries may or may not be a good idea
    # and breaks building for foreign architectures
    echo "override_dh_strip:" >> debian/rules
}


# Not implemented yet: add an override to a dh-style debian/rules file
#  (as created by debian_rules (see above) or dh_make
debian_rules_add_override() {
    :
}


# Not implemented yet
debian_install() {
    :
}


# move pkg install scripts out of the way
#  TODO: Add them to the pkg documentation
disable_install_scripts() {
    #mkdir -vp $DIR/usr/share/doc/$PKG_NAME/original_install_scripts
    for script in preinst postinst prerm postrm; do
        [ -r debian/$script ] \
            && mv -v debian/$script debian/$script.orig
    #[ -r $script ] && sed -i -e "1c#\!/bin/sh -x" $script
    done
}


# copy over the created debs:
drop_result() {
    if [ "$1" ]; then
        cp $@ .
    else
        cp $BUILD_DIR/*.deb .
    fi
}


# detect the archive type of the given archive and extract it
extract() {
    local blob="$1"
    local dir=$2
    local mime=`file --brief --mime-type "$blob"`

    [ "$dir" ] || dir=$BUILD_DIR

    case $mime in

        application/x-gzip)
            case $blob in
                *.tar.gz|*.tgz)
                    tar xfz $blob -C $dir
                    ;;
                *)
                    gunzip -cd > $dir/`basename "$blob" .gz`
                    ;;
            esac
            ;;
        
        application/zip)
            unzip -d $dir $blob
            ;;

        application/x-dosexec)
            cabextract -d $dir $blob
            ;;

        application/x-rpm)
            (
                archive=`readlink -f "$blob"`
                cd $dir
                fakeroot alien -dsg --scripts --verbose "$archive"
            )
            ;;
        
        *)
            abort "Unknown archive type $mine for $blob"
            ;;
    esac
}


fetch() {
    local url=$1
    
    # guess the filename from the Location: header of the HTTP response
    #  (to prevent downloaded files being called 'download' aso.
    filename=`curl -I $url | sed -ne "s|Location: .*/\(.*\)\(?.*\)|\1|p"`
    # fallback:
    [ "$filename" ] || filename=`basename $url`
    curl -o $filename $url
    echo $filename
}


prepare() {
    # some preparations:
    ME=`whoami`
    [ "$DEBEMAIL" ] || DEBEMAIL="$ME@"`hostname -f`
    [ "$DEBFULLNAME" ] || DEBFULLNAME=`getent passwd $ME | cut -f 5 -d : | cut -f 1 -d,`
    
    BUILD_DIR=`mktemp -d -p .`
}

#export these functions to subshells (ie. our recipes):
export abort add_dependency cleanup debian_control debian_rules \
    disable_install_scripts extract fetch prepare 

#########
#
# minimal recipe invocation logic
#

# search path for recipes:
RECIPE_DIRS="`dirname $0`/recipes /usr/lib/debutant/recipes"

# ... /usr/local/lib/debutant/recipes??, /var/lib/debutant/recipes???

RECIPE=$1
shift

FOUND=

for D in $RECIPE_DIRS; do
    [ -d $D ] || continue
    if [ -e $D/$RECIPE ]; then
        FOUND=1

        # preparations are performed here, not inside recipes
        prepare
        . `dirname $0`/recipes/$RECIPE $@
        break
    fi
done

[ "$FOUND" ] || abort "No recipe found for '$RECIPE'"

# TODO: cleanup could be performed here, not inside recipes
